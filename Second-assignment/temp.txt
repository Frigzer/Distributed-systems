#include <iostream>
#include <vector>
#include <queue>
#include <set>
#include <algorithm>
#include <cstdlib>
#include <ctime>

using namespace std;

const int N = 5; // liczba procesów
const int M = 10; // liczba żądań

struct Request {
    int timestamp;
    int process_id;
};

struct Process {
    int id;
    int clock = 0;
    bool requesting = false;
    Request current_request;
    vector<int> go_ahead; // 0 - brak, 1 - sukces
    vector<int> deferred; // ID procesów, którym jeszcze nie wysłano GO

    Process(int _id) : id(_id) {
        go_ahead.resize(N, 0);
    }

    void reset_request(int timestamp) {
        requesting = true;
        current_request = { timestamp, id };
        fill(go_ahead.begin(), go_ahead.end(), 0);
        go_ahead[id] = 1; // nie wysyłamy do siebie
    }

    bool can_enter_cs() {
        for (int i = 0; i < N; ++i)
            if (go_ahead[i] == 0)
                return false;
        return true;
    }

    void print_status() {
        cout << "Process " << id << " entered CS. Go-ahead list: ";
        for (int i = 0; i < N; ++i)
            if (i != id)
                cout << "P" << i << "=" << go_ahead[i] << " ";
        cout << endl;
    }
};

vector<Process> processes;
int global_time = 0;

// porównanie żądań (timestamp, process_id)
bool has_priority(const Request& a, const Request& b) {
    return (a.timestamp < b.timestamp) ||
        (a.timestamp == b.timestamp && a.process_id < b.process_id);
}

void send_request_to_all(int pid) {
    Process& sender = processes[pid];
    for (int i = 0; i < N; ++i) {
        if (i == pid) continue;
        Process& receiver = processes[i];

        if (!receiver.requesting) {
            sender.go_ahead[i] = 1;
        }
        else {
            if (has_priority(sender.current_request, receiver.current_request)) {
                sender.go_ahead[i] = 1;
            }
            else {
                receiver.deferred.push_back(pid);
            }
        }
    }
}

void release_cs(int pid) {
    Process& p = processes[pid];
    p.requesting = false;

    for (int to_pid : p.deferred) {
        processes[to_pid].go_ahead[pid] = 1;
    }
    p.deferred.clear();
}

int main() {
    srand(time(0));
    processes.reserve(N);
    for (int i = 0; i < N; ++i) processes.emplace_back(i);

    vector<Request> requests;
    for (int i = 0; i < M; ++i) {
        int proc = rand() % N;
        requests.push_back({ ++global_time, proc });
    }

    for (Request req : requests) {
        Process& p = processes[req.process_id];
        p.clock = max(p.clock, req.timestamp) + 1;
        p.reset_request(req.timestamp);

        send_request_to_all(p.id);

        while (!p.can_enter_cs()) {
            // symulacja "czekania"
        }

        p.print_status();

        release_cs(p.id);
    }

    return 0;
}
